#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
Copyright (c) 2012 Brookhaven Science Associates, as Operator of
    Brookhaven National Laboratory.
mrfioc2 is distributed subject to a Software License Agreement found
in file LICENSE that is included with this distribution.
"""

import re, sys, os.path
from warnings import warn
from optparse import OptionParser

from pyPDB.po.grammer import PO

parser = OptionParser(usage='%prog [options] <-i file.po ...> <input.db | in.edl>')
parser.add_option('-i', '--po', action='append', default=[],
                  help='Translation file(s) to apply', metavar='FILE')
parser.add_option('-o', '--output', default='.',
                  help='Location to write output files', metavar='DIR')
parser.add_option('-F', '--flat', action="store_true", default=False,
                  help="Don't preserve directory structure in output")
parser.add_option('-R', '--reverse', action='store_true', default=False,
                  help='Apply reverse translation')
parser.add_option('-m', '--mode', default="db", metavar="NAME",
                  help='Replacement mode (db, edl, opi, xml, proto, alias)')

opts, args = parser.parse_args()

if len(opts.po)==0:
    parser.error('No translation files specified')

mappings={}
src={}

def loadPO(file):
    x=PO.parseFile(file)

    for orig, sub in x:
        if len(orig.strip())==0 or len(sub.strip())==0:
            continue
        if orig in mappings:
            if mappings[orig] != sub:
                warn("Found duplicate definition of '%s'\nIn '%s'\nPrevious '%s'"% \
                        (orig, file, src[orig]))
            else:
                pass # duplicate, but idential

        else: # new mapping
            mappings[orig]=sub
            src[orig]=file

for po in opts.po:
    loadPO(po)

if opts.reverse:
    fail=False
    nm={}
    for orig, sub in mappings.iteritems():
        if sub not in nm:
            nm[sub]=orig

        else:
            print >>sys.stderr,"""Un-reversable mapping
From %(origfile)s '%(orig)s = %(sub)s'
and
From %(prevfile)s '%(prev)s = %(sub)s'
""" % {'orig':orig, 'sub':sub, 'prev':nm[sub],
       'origfile':src[orig], 'prevfile':src[nm[sub]]}
            fail=True
    if fail:
        sys.exit(1)
    mappings=nm

#valid   = PP.alphanums + '$:-[]{}<>()'

actions=[]

if opts.mode in ['db', 'edl']:
    for orig, sub in mappings.iteritems():
        if opts.mode=='edl':
            orig = orig.replace('{', '\{')
            sub = sub.replace('{', '\{')
            orig = orig.replace('}', '\}')
            sub = sub.replace('}', '\}')

        # look behind for beginning of line or a non-name charactor
        # look ahead for end of line or a non-name charactor

	# Records names look like
        #  record(type, "name")
        #  field(INPA, "name.VAL EXTRA")
        #  field(INPA, name.VAL)
        # So break names on whitespace, '.', or '"'
        tst = '(?:^|(?<=[\s,"\(]))' + re.escape(orig) + '(?:$|(?=[\s.,"\)]))'
        actions.append((re.compile(tst), sub))

elif opts.mode in ['xml','opi']:
    from xml.sax.saxutils import escape

    for orig, sub in mappings.iteritems():
        # Like DB except record names are found
        # enclosed like ">$(1):name.FLD<"
        orig, sub = map(escape, (orig,sub))
        tst = '''(?:^|(?<=[\s'">]))''' + re.escape(orig) + '''(?:$|(?=[\s.'"<]))'''
        actions.append((re.compile(tst), sub))

elif opts.mode=='proto':
    for orig, sub in mappings.iteritems():
        # Like DB except that macros are "\$1" and record names are found
        # enclosed like "(\$1:name.FLD)"
        tst = '(?:^|(?<=[\s"\(]))' + re.escape(orig) + '(?:$|(?=[\)\s."]))'
        actions.append((re.compile(tst), sub))

elif opts.mode=='alias':
    if opts.output=='.':
        out=sys.stdout
    else:
        out=open(opts.output, 'w')

    for orig, sub in mappings.iteritems():
        print >>out,'alias("%s",\t"%s")'%(orig,sub)
    out.close()
    sys.exit(0)

else:
    print >>sys.stderr,"Unknown replacement mode",opts.mode
    sys.exit(1)

if not os.path.exists(opts.output):
    os.makedirs(opts.output)

for f in args:
    if opts.flat:
        out=os.path.join(opts.output, os.path.basename(f))
    else:
        out=os.path.normpath(os.path.join(opts.output, f))
        DN=os.path.dirname(out)
        if len(DN.strip())>0 and not os.path.exists(DN):
            os.makedirs(DN)

    # Use binary I/O to ensure the EOL stays the same
    # in output files
    inp=open(f, 'rb')
    val=inp.read()

    for pat, sub in actions:
        val=pat.sub(sub, val)

    inp.close()
    # close input file in case it is about to be overwritten

    out=open(out, 'wb')
    out.write(val)

    out.close()
