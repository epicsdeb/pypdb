#!/usr/bin/env python
# -*- coding: utf-8 -*-

import re, sys
from warnings import warn
from optparse import OptionParser

from pyPDB.dbd.expand import findFile
from pyPDB.po import POEnt, writePO

linktypes = ['DBF_INLINK', 'DBF_OUTLINK', 'DBF_FWDLINK']
infofields = ['EGU', 'DESC']

parser = OptionParser()
parser.add_option("-I", dest='include', action='append', default=[],
                  help='Add to search path', metavar='PATH')
parser.add_option("-o", '--output',
                  help='Output file', metavar='FILE')

opts, args = parser.parse_args()

if opts.output is None:
    out=sys.stdout
else:
    out=file(opts.output, 'w')

if len(opts.include)==0:
    opts.include=['.']

attrpat=re.compile('^\s* (\S+) \s* "(\\"|[^"]*)" \s*$', re.X)

# widget attributes known to contain PV names
PVattrs=[
'alarmPv',
'colorPv',
'controlPv',
'filePv',
'indicatorPv',
'readPv',
'visPv',
'xPv',
'yPv',
]

# Just a record name with optional field
#   record.FLD
plainpv=re.compile('^\s*([^.]+)\.?.*$')


def extractRec(s):
    """ Extract record name(s) from string
    """
    
    if s.startswith('CALC'):
        # May contain several record names
        #   CALC\\\{(((A=0)&&(B=0)))\}($(P)$(M).DMOV, $(P)$(M).STAT)

        _,_,pvs = s.partition('\\}')
        pvs=pvs.strip().strip('()')

        if len(pvs)==0:
            warn('CALC with no PVs? "%s"'%s)
            return []
        
        pvs=pvs.split(',')
        pvs=map(str.strip, pvs)
        # strip field names
        pvs=map(lambda p:extractRec(p)[0],pvs)

        return pvs

    else:
        M=plainpv.match(s)
        if M is None:
            return []
        return [M.group(1)]

entries={}

for fname in args:

    try:
        fullname=findFile(fname, path=opts.include, env='EDMDATAPATH') 

        fd=open(fullname, 'rU')

    except IOError:
        print >>sys.stderr, "Can't find/read",fname,"in",', '.join(opts.include)
        sys.exit(1)

    for ln, L in enumerate(fd.readlines()):
        #print ln,L
        M=attrpat.match(L)
        if M is None:
            continue

        if M.group(1) not in PVattrs:
            continue
        
        pvs=extractRec(M.group(2))
        pvs=list(set(pvs)) # make unique

        for pv in pvs:
            try:
                ent=entries[pv]
            except KeyError:
                ent=POEnt(pv)
                entries[pv]=ent

            if M.group(1) not in ent.comExt:
                ent.comExt.append(M.group(1))

            ent.refs.append('%s:%d'%(fname,ln))

        print fname,ln,pvs

    fd.close()

entries=entries.values()
entries.sort()

writePO(out, entries, header={'path':opts.include})

sys.exit(0)
